function r(r,e=0,n=1,t){let u=[];for(let o=0;o<n;o++){let n=0,o=0,f=[];const i=127;for(;;){if(e>=r.length)throw new RangeError("buffer overflow");let t=r[e++];if(o|=(t&i)<<n,n+=7,n>=8&&(f.push(255&o),o>>=8,n-=8),t<=i)break}n&&f.push(o),u.push(t(f.reverse()))}return u.push(e),u}function e(r){return"0x"+r.map((r=>r.toString(16).padStart(2,"0"))).join("")}function n(r){let e=r.reduce(((r,e)=>256*r+e),0);if(!Number.isSafeInteger(e))throw new RangeError("unsafe");return e}function t(n,t,u){return r(n,t,u,(r=>BigInt(e(r))))}function u(n,t,u){return r(n,t,u,e)}function o(e,t,u){return r(e,t,u,n)}function f(r,e,n=0){if("number"==typeof e&&!Number.isSafeInteger(e))throw new RangeError("unsafe");if((e=BigInt(e))<0)throw new RangeError("negative");const t=127n;for(;e>t;)r[n++]=128|Number(e&t),e>>=7n;return r[n++]=Number(e),n}export{o as read,t as readBigInt,u as readHex,f as write};
